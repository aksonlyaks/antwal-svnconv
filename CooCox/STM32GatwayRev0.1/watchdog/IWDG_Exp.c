/**
  *****************************************************************************
  * @title   IWDG_Exp
  * @author  CooCox
  * @date    15 Mar 2011
  * @brief   In this example, SysTick is configured to generate an interrupt
  *          every 250 ms. In the SysTick interrupt service routine (ISR),
  *          the IWDG counter is reloaded to prevent an IWDG reset and LED(PB9)
  *          is toggled.An EXTI is connected to a specific GPIO pin(TAMPER, PC13)
  *          and configured to generate an interrupt on its falling edge.
  *          The EXTI Line is used to simulate a software failure: when the EXTI
  *          Line event is triggered (by pressing the TAMP push-button on the board),
  *          the corresponding interrupt is served. In the ISR, the LED(PB9)turns
  *          off and the EXTI line pending bit is not cleared. So the CPU executes
  *          the EXTI line ISR indefinitely and the SysTick ISR is never
  *          entered (IWDG counter not reloaded). As a result, when the IWDG counter
  *          reaches 00h, the IWDG generates a reset. If the IWDG reset is generated,
  *          LED(PB8) is turned on after the system resumes operation.
  *          It has been tested on MCBSTM32 board, STM32F103RBT6 device.
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

#include "stm32f10x_gpio.h"
#include "stm32f10x_iwdg.h"
#include "stm32f10x_rcc.h"
#include "watchdog.h"
#include "misc.h"


/***************************************************************************//**
 * @brief  SysTick is configured to generate an interrupt every 250 ms.
 *         In the SysTick interrupt service routine (ISR), the IWDG counter
 *         is reloaded to prevent an IWDG reset. The EXTI Line is used to simulate
 *         a software failure: when the EXTI Line event is triggered (by pressing
 *         the TAMP push-button on the board), the corresponding interrupt is served.
 *         In the ISR, the LED(PB9)turns off and the EXTI line pending bit is not
 *         cleared. So the CPU executes the EXTI line ISR indefinitely and the
 *         SysTick ISR is never entered (IWDG counter not reloaded).
 ******************************************************************************/
void IWDG_Exp(void)
{


    /* Enable  AFIO clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);

    /* In Debug mode when cpu halts also halt watchdog clk
     * This is done by setting DBG_WWDG_STOP bit(9th bit) in DBGMCU_CR
     * register  whose address is 0xE0042004
     * (*( __IO uint32_t *)0xE0042004) |= (1<< 9);
     */

	#define DBGMCU_CR   	(*( __IO uint32_t *)0xE0042004)
	#define DBG_IWDG_STOP 	(1 << 8)

    //set the bit
    DBGMCU_CR  |= DBG_IWDG_STOP ;
    //clear the bit
    //DBGMCU_CR  &= ~DBG_IWDG_STOP ;

    /* IWDG timeout equal to 350ms (the timeout may varies due to LSI frequency
     dispersion) -------------------------------------------------------------*/
    /* Enable write access to IWDG_PR and IWDG_RLR registers */
    IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);

    /* IWDG counter clock: 32KHz(LSI) / 256 = 125Hz *///therefore time out is 32seconds
    IWDG_SetPrescaler(IWDG_Prescaler_256);

    //reload value must be between 0 <= 0xFFF(4095)

    /* Set counter reload value to 0xFFF ie 32 seconds  */
    IWDG_SetReload(0xFFF);

    /* Reload IWDG counter */
    IWDG_ReloadCounter();

    /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
    IWDG_Enable();
}







